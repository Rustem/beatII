% easychair.tex,v 3.2 2012/05/15
%
% Select appropriate paper format in your document class as
% instructed by your conference organizers. Only withtimes
% and notimes can be used in proceedings created by EasyChair
%
% The available formats are 'letterpaper' and 'a4paper' with
% the former being the default if omitted as in the example
% below.
%
\documentclass{llncs}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

% This provides the \BibTeX macro
\usepackage{doc}
\usepackage{makeidx}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{longtable}
\usepackage{paralist}
\usepackage{color}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{txfonts}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=blue,
    linkcolor=black,
    urlcolor=blue
}

% Let's style the code!
% Set-up code visualisation
\lstset{fancyvrb=true}
\lstset{
language=java,                % the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                % will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
keywordstyle=\color{blue},
commentstyle=\color{green},
stringstyle=\color{red},
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,                   % adds a frame around the code
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=t,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
%title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                % also try caption instead of title
escapeinside={\%*}{*)},         % if you want to add a comment within your code
morekeywords={*,...}            % if you want to add more keywords to the set
}
\lstset {
    keywordstyle=\color[rgb]{0,0,1},          % keywords in blue
    commentstyle=\mcommentfont,               % comments
    stringstyle=\color[rgb]{.627,.126,.941},  % strings in purple
    commentstyle=\color[rgb]{.133,.545,.133}
}

% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% If you plan on including some algorithm specification, we recommend
% the below package. Read more details on the custom options of the
% package documentation.
%
% \usepackage{algorithm2e}

%\makeindex

%% Document
%%
\begin{document}

%% Front Matter
%%
% Regular title as in the article class.
%
\title{Ensuring Faultless Communication Behaviour\\
       in an E-Commerce Cloud Application}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair

\titlerunning{Faultless Commuication in a Cloud}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{
	Rustem A. Kamun \and Ross Horne
}

% Institutes for affiliations are also joined by \and,
\institute{
  Kazakh-British Technical University, 
  Faculty of Information Technology,\\
  Almaty, Kazakhstan\\
  \email{r.kamun@gmail.com}
 }
%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Kamun \& Horne}


%\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
  An increasing scope and complexity of Web Services raises a new challenge of controlling their interaction. The goal of this work is to ensure that processes in a production Cloud are correctly interacting according to a specification of their communication behaviour. To accomplish this goal, we employ session types to analyse the global and local communication patterns. Session types represents ``formal blueprints" of how communicating participants should behave and offers a concise view of the message flows.
  
  This work confirms the feasibility of application of session types on ``non-linear'' business protocols used by an e-commerce Cloud provider and developed in Session-Java, an extension of Java implementing Session-Based programming. Furthermore, we highlight the importance of this approach for services replicated across multiple Cloud providers each of which must correctly cooperate.
\end{abstract}

%\setcounter{tocdepth}{2}
%{\small\tableofcontents}

%\section{To mention}
%
%Processing in EasyChair - number of pages.
%
%Examples of how EasyChair processes papers. Caveats (replacement of EC
%class, errors).

%\pagestyle{empty}


%------------------------------------------------------------------------------
\section{Introduction}
\label{sect:introduction}

%The growing needs for information availability and accessibility present new challenges for application development.
The need for distributed highly available services presents challenges for application development.
%Two forces working in parallel with regards to the need for integration.
It is necessary for applications to be integrated both within an enterprise, and between businesses.
Service-Oriented Architectures (SOA) are widely accepted as a paradigm for integrating software applications within and across organizational boundaries.
In this paradigm, independently deployed applications are exposed as Web Services which are then 
interconnected using a stack of standards (depicted in Figure~\ref{fig:soa-stack}). 
		
There remain open challenges when it comes to managing service interactions that go beyond simple sequences of requests and responses or involve large numbers of participants (multi-party communication). A need arises for new transaction implementations, more suitable for the Web.
One technique for describing collaboration between a collection of services is a choreography model.
Choreographies capture the interactions in which the participating services engage and interconnections between these interactions, including control-/data-flow dependencies.
However, a choreography does not describe internal effects within a participating service. Furthermore, a choreography does not specify how a global description can be executed.
%, and, therefore, its functionality is not clear.

		\begin{figure}[ht]
		\begin{centering}
		\scalebox{0.7}{
		\includegraphics[width=0.5\textwidth]{resources/WS_stack.png}
                }
		\caption{Stack of WS Standards}
		\label{fig:soa-stack}
		\end{centering}
		\end{figure}

Much literature exist on the specification of systems that describe services from the local viewpoint~\cite{cs-processes,alg-seq-processes}.
The concept of a participant in a communication is essential in complex interactions. Applications include business transactions with short life span, operating in closely coupled context (e.g.\ the online stock exchange (ForEX), and e-commerce services based on Buyer-Seller-Shipper (BSH) protocols). Although, in closely coupled settings, the SOA standards may incur a significant performance overhead.
Highly available services are likely to have a long life span that may result in deadlock.
%In addition there is no special concept of the participants of communication. 

\begin{comment}
	\begin{compactenum}
	   \item business transactions with short life span, operating in closely coupled context, where SOA standards may become a trap (online stock exchange(ForEX), services based on BSH protocol\footnote{Buyer-Seller-Shipper protocol} such as e-commerce services);
	   \item applications with a long life span that may result in deadlock.
	\end{compactenum}
\end{comment}

Such challenges motivated the design of Web Services Choreography Description Language (WS-CDL)~\cite{session-types-sessions}. The WS-CDL working group identified critical issues~\cite{ws-critical-overview} including:
\begin{compactenum}
	\item the need for tools to validate conformance to choreography specifications to ensure correct cooperation between Web Services;
	\item design time validation and verification of choreographies to guarantee correctness of such properties like deadlock, livelock e.g.\ behaviour of participants conforms to the choreography interface.
\end{compactenum}

The aforementioned challenges can be tackled by adopting a solid foundational model. Successful approaches based on session types~\cite{session-types-sessions,carbone2007structured} include: the Chor and Jolie programming languages of Carbone and Montesi~\cite{chor-lang,carbone2013deadlock} based on sessions and trace sets~\cite{chor-essence}; Session-Java~\cite{sj-lang}, Scribble~\cite{honda2011scribbling} and Session C~\cite{ng2012multiparty} due to Honda and Yoshida; Sing\#~\cite{basu2012deciding} that extend Spec\# with choreogrphies; and UBF(B)~\cite{armstrong2002getting} for Erlang.

In this paper, we demonstrate a method of controlling process interactions represented by sessions. The formal theory based on session types ensures communication safety by verifying that session implementations of each engaged participant conform to the defined protocol specification. In order to evaluate the feasibility of this theory we use Session-Java, an extension to Java language. Session Java works by specifying the intended process transaction protocol using session types and implementing the interaction using session operations.

%Through these we are aiming to confirm the suitability of Session-Java as an implementation of business to business transactions. We want to explore the agility and robustness of the language and the scalability as scenarios vary in size but also complexity. In addition we will be looking for things such as ease of programming in SJ, any limitations, bugs or non-implementable scenarios.


In Section~\ref{sect:basics} we provide an overview of SJ.
In Section~\ref{sect:impl}, we provide detailed explanation of business protocols used by an e-commerce Cloud provider.
Finally, in Section~\ref{sect:highlights}, we highlight how session types can improve the design of Intercloud~\cite{intercloud} communication protocols.


%------------------------------------------------------------------------------
\section{Basics of Session-Java}
\label{sect:basics}

Session programming begins from the protocols specification for interaction (using session types), which can then be concretely implemented using structured communication operations available on session sockets. Session programming is applicable for applications where the parties or components cooperate according to specified protocols: session types are formal specifications of such protocols. Session types describe structured sequences of interaction including basic message passing, branching and recursion. A session is an instance of a session type, i.e.\ the unit of interaction encapsulating one run of a protocol. From the perspective of abstraction, each session, is conducted on a separate channel. 

Session programming in SJ consists of the following ordered actions:

\begin{compactenum}
  \item design specification (protocol) of target communication;
  \item mapping protocols into the programs for each participant. For instance, in BSH protocols, we can distinguish three main participants whose actions (processes) are mapped to corresponding programs (software component);
  \item By utilizing session programming constructs, implementing the protocol, where each operation is performed as method call;
  \item verification of sessions fulfilment by  compiler;
  \item execution and system testing.
\end{compactenum}

\subsection{Protocol Specification}
Session programming begins by declaring the protocol for the intended cooperation as follows:

\begin{equation*}
\text{protocol name \{\dots\}}
\end{equation*}
where name identifies the protocol, following the standard Java naming rules. The body of the protocol defines a \textit{session type}, according to the grammar in Figure~\ref{tab:prot-spec}.

\begin{figure}
\begin{gather*}
\begin{array}{rlr}
T \Coloneqq & T\mathbin{.}T & \mbox{Sequencing} \\ 
       \mid & \texttt{begin} & \mbox{Session initiation} \\
       \mid & \mathopen{!}\left<M\right> & \mbox{Message send} \\ 
       \mid & \mathopen{?}\left(M\right) & \mbox{Message receive} \\
       \mid & \oplus \left\{L_1 \colon T_1,\dots, L_n \colon T_n \right\} & \mbox{Session branching} \\ %??Why not use the ASCII syntax, since you use it in examples.
       \mid & \oplus \left[T\right]* & \mbox{Session iteration} \\ 
       \mid & \texttt{rec}\,L\left[T\right] & \mbox{Session recursion scope} \\ 
       \mid & \mathopen{\#}L & \mbox{Recursive jump} \\ 
       \mid & \mathopen{@}p & \mbox{Protocol reference} \\
\end{array}
\end{gather*}
\caption{SJ protocol specification}\label{tab:prot-spec} 
\end{figure}

The session type shows how a session should be designed in terms of actions that the participant should perform. The key point is that the implementation of a session is governed by associated protocol: the SJ compiler (Polyglot\footnote{\url{http://www.cs.cornell.edu/Projects/polyglot/}. Extensible compile framework.}). It can be clearly seen from the Table \ref{tab:prot-spec}, that SJ has enough constructs to describe a diverse range of complex interactions: message passing, conditional and repeated expressions. Its worth noting, that each session type element has its dual element, because there is a requirement that two parties implement compatible protocol such as the specification of one party has dual relation to another party.

\subsection{Higher Order Communication}
In order to describe richer behaviour, SJ has a feature of subtyping. It means that message types can themselves be session types. It also enhances the agility of the type system by allowing the participants in a session to follow different protocols which are compatible \cite{higher-order-comm}. Such communication can be expressed by the following dual constructs:

\begin{equation*}
\mathopen{!}\left<\mathopen{?}\left(\text{int}\right)\right> \hspace{2cm} \mathopen{?}\left(\mathopen{?}\left(\text{int}\right)\right)
\end{equation*}

In short, it says that we are expected to send and receive a session of type $\mathopen{?}\left(\text{int}\right)$. Higher order communication, as we will convince further, is often referred to a session delegation. Figure \ref{fig:sj-delegation} shows a basic delegation scenario.

\begin{figure}[ht]
\centering
\scalebox{0.7}{
\includegraphics[width=0.8\textwidth]{resources/sj-delegation.png}}
\caption{Session delegation}\label{fig:sj-delegation}
\end{figure}

The left part illustrates the session configuration before the delegation is performed: User engaged in a session $s$ of type $\mathopen{!}\left<\text{int}\right>$ with V3na (Cloud), while Cloud is also involved in a session $s'$ with SaaS of type $\mathopen{!}\left<\mathopen{?}\left(\text{int}\right)\right>$. So, instead of accepting the integer from User himself, Cloud delegates his role in $s$ to SaaS, so that he will receive this message. This delegation action corresponds to higher-order send type for the session $s'$ between Cloud and SaaS. The right part of figure illustrates the change in session configuration after the delegation has been performed: User now directly interacting with SaaS for the session $s$.

\subsection{Protocol Implementation using Session}
\paragraph{Another meaning for sockets}
Session sockets are implementing the actual session code according to the specified session type (protocol). They are represent the endpoints (participants) of a session connection: each of the parties owns one endpoint and performs the specified interactions via the SJ session operations on that endpoint. In SJ session sockets are objects that extend the abstract \textit{SJSocket} class. \textit{SJRSocket::SJSocket} and \textit{SJFSocket::SJSocket}, both, employ TCP as underlying transport. SJ is distinguishing session client and server sockets, where the former are used to request sessions from the latter.

\paragraph{Session operations}
After creating a protocol (session type) and encapsulating the session into SJ socket, it can be implemented within a session-try scope using the session operations depicted in Figure \ref{tab:session-ops}.


\begin{figure}
\begin{gather*}
\begin{array}{lrr}
s.request() 	& \mid 		    & \mbox{\texttt{begin}} \\
s.send(m)   	& \mid	 		& \mathopen{!}\left<M\right> \\
s.receive() 	& \mid	 		& \mathopen{?}\left(M\right) \\
s.outbranch(L) \ \{P\} & \mid		& \mathopen{!}\left\{L\mathopen{:} T\right\} \\
\texttt{s.inbranch()} \ \{case L1\mathopen{:} {P1}\dots case Ln\mathopen{:}{Pn}\} & \mid & \mathopen{?}\left\{L_1\colon 
                                        T_1,\dots, L_n\colon T_n\right\} \\
s.outwhile(cond) \ \{P\} 		& \mid & \left[T\right]\mathopen{*} \\
s.inwhile() \ \{P\} 		 	& \mid & \mathopen{?}\left[T\right]\mathopen{*} \\
s.recursion(L) \ \{P\} & \mid & \texttt{rec}\,L\left[T\right] \\
s.recurse(L) & \mid & \mathopen{\#}L \\
\end{array}
\end{gather*}
\caption{SJ protocol specification}\label{tab:session-ops} 
\end{figure}

The session operations are invoked via session in a method call-like manner. To delegate a session, the session socket variable must be passed to a send operation on the target session.

\begin{lstlisting}
s1.send(s2) // !<T>, where T is the remaining session type of 's2'
\end{lstlisting}


Only active session sockets can be delegated. The receive operation receives delegated sessions:

\begin{lstlisting}
SJSocket s2 = s1.receive()
\end{lstlisting}

%------------------------------------------------------------------------------
\section{Business case studies}
\label{sect:impl}

V3na.com\footnote{\url{http://v3na.com}. Cloud platform for optimizing your business performance.}
is an e-commerce Web portal that sells SaaS applications for business needs. V3na has developed on Django framework --- a high-level Web framework for python. %Further information: \url{https://www.djangoproject.com/}}.
The persistence layer is based on MongoDB and Memcached. One of the challenging task was to automate the process of SaaS integration. By integration we understand the following processes with a particular SaaS application\footnote{Source code is available at \url{https://github.com/Rustem/Master-thesis}.}:

\begin{compactitem}
\item  connection: SaaS user can connect SaaS for trial period by simply clicking on the button;

\item  subscription extension and freezing;

\item  payment confirmation;

\item one entry point to all user's applications.
\end{compactitem}

\subsection{Simple Scenario}
\paragraph{Protocol declaration} As a starting point, let's specify simple business protocol of one of the processes just mentioned, SaaS connection. Informally, it may be interpreted as follows:
\begin{enumerate}
\item  User begins a request session (s) with cloud service (V3na) and sends the request ``Connect SaaS'' as JSON-encoded message.

\item  V3na sends either:

\item  FAIL, if user has no active session (not signed in on V3na) and further interaction terminates 

\item  OK, if user has logged in and request data has passed validation steps. Then Cloud initiates a new session (s') with SaaS and requests it for new user connection with HttpRequestJSONMessage.

\item  If OK label take place, Cloud initiates a new session (s') with SaaS and requests it for new user connection with HttpRequestJSONMessage. finally SaaS responds to Cloud with connection status (OK, FAIL) and V3na sends this status to User. Both sessions have to be terminated.
\end{enumerate}

\textit{Protocols.} The decision in the protocol will be incorporated through the use of outbranch. So the whole scenario is presented on Table \ref{tab:protocols-sc1}.

{
\lstset{
framerule=0pt,
numbers=none
}
\begin{longtable}{|p{0.3\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
\caption{Protocols of scenario \# 1}
\label{tab:protocols-sc1} \\ \hline
User & Cloud (V3na) & SaaS \\ \hline
\endhead

\begin{lstlisting}
protocol p_uv { 
  begin.
  !<JSONMessage>. 
  ?{
    OK: ?(JSONMessage).?(int),
    FAIL: 
  }
}
\end{lstlisting}
&
\begin{lstlisting}
p_vu { 
  begin.?(JSONMessage).!{
    OK: !<JSONMessage>.!<int>,
    FAIL: 
  }
protocol http_req_rep {
  !<JSONMessage>.
  ? (JSONMessage)
}
protocol p_vs { 
  begin.@http_req_rep 
}
\end{lstlisting}
&
\begin{lstlisting}
protocol p_sv { 
  begin.
  ?(JSONMessage). !<JSONMessage> 
}
\end{lstlisting}
\\ \hline
\end{longtable}
}

\paragraph{Interactions.} The general syntax for global description has been interpreted into a sequence UML diagram, as depicted in Figure \ref{fig:interaction-overview-sc1}. The whole syntax is on the down-left side of the figure. In case of choice, terminated branches are out of scope of the main picture, but still a subpart of the whole diagram. Next step is implementation of this diagram in Session-Java.

\begin{figure}[ht]
\centering
\scalebox{0.3}{
\includegraphics{resources/interaction-sc1.png}}
\caption{Overview of interactions for Scenario \# 1}
\label{fig:interaction-overview-sc1}
\end{figure}

The main feature of SJ in this scenario is that choice can be expressed by using \textit{outbranch} construct.

\subsection{Complicated Scenario}
New scenario is a bit harder in complexity. We are going to utilize looping construct as well as demonstrating \textit{session delegation}. The description of the scenario of this subsection presented below as follows:
\begin{compactenum}
\item  User begins a request session (s) with cloud service (V3na)

\item  V3na asks User to login, so next User provides V3na with login and password Strings.

\item  V3na receives User credentials and verifies them: If User is authenticated with minimal amount of tries or amount of tries is out of limit, he is allowed to continue further interactions with V3na, otherwise --- not. Go back to step 2.

\item  If User is not allowed to access V3na, the interaction between User and V3na continues on DENY-branch, otherwise --- on ACCESS-branch.

\item  If next branch is ACCESS, User sends his connection request with details to V3na. V3na creates new session with SaaS (s') and delegates the remaining session s with User on the latter and sends last user request details. Session s' is terminated.

\item  SaaS continues interaction with user by session s. By steps of validation-verification, SaaS either responds User to proceed interaction by branch OK or FAIL. In both cases User receives from SaaS directly the reason and status of his request. Session s is terminated.
\end{compactenum}

\paragraph{Protocols.} First of all, the protocol provided with iterations using $![\dots]*$ $?[\dots]*$. Then protocol introduces higher order operations of type $!<T>\ \ ?<T>$. Full description is provided in tables \ref{tab:user-cloud-protocol} and \ref{tab:cloud-saas-providers}.

{
\lstset{
framerule=0pt,
numbers=none
}
\begin{longtable}{|p{0.45\textwidth}|p{0.45\textwidth}|}
\caption{User-Cloud protocols}\label{tab:user-cloud-protocol} \\ \hline
User & Cloud \\ \hline \endhead
\begin{lstlisting}
protocol p_uv { 
  begin.?[!<String>.!<String> ]*.
  ?{
   ACCESS: !<JSONMessage>.
   ?{
     OK: ?(JSONMessage), FAIL: ?(JSONMessage)
   },
  DENY: ?(String)
  } 
}
\end{lstlisting}
&
\begin{lstlisting}
private protocol p_vu { 
  begin.
   ![ ?(String).?(String) // login password
     ]*.
  !{
    ACCESS: ?(JSONMessage).
    !{
      OK: !<JSONMessage>, FAIL: !<JSONMessage>
     },
      DENY: !<String>
   } 
}
\end{lstlisting}
\\ \hline
\end{longtable}
}



{
\lstset{
framerule=0pt,
numbers=none
}
\begin{longtable}{|p{0.45\textwidth}|p{0.45\textwidth}|}
\caption{Cloud-SaaS protocols}\label{tab:cloud-saas-providers} \\ \hline
Cloud & Saas \\ \hline \endhead
\begin{lstlisting}
protocol p_vs {
  begin.
  !< !{
    OK: !<JSONMessage>, 
    FAIL: !<JSONMessage>
  } >.!<JSONMessage>    
}
\end{lstlisting}
&
\begin{lstlisting}
protocol p_msg { 
  !{
    OK: !<JSONMessage>,
    FAIL: !<JSONMessage> 
  }
}

protocol p_sv {
  begin.?(@p_msg).?(JSONMessage) 
}
\end{lstlisting}
\\ \hline
\end{longtable}
}

Unlike the previous protocol, the Cloud-Saas protocol significantly altered, also authentication process is added to the protocol in interaction between User --- Cloud. It is important to note that 

\begin{lstlisting}
!<!{
        OK: !<JSONMessage>,
        FAIL: !<JSONMessage> 
}>
\end{lstlisting}

corresponds to a higher-order message. The !$<\dots>$ means that it is the Cloud that is passing the high order message and everything inside it is the protocol of the session that Saas should perform with the User. In Saas --- Cloud, the protocol defined in more subtle way containing higher order messages by first defining them and then including them in the protocol. For syntactic convenience, one protocol can be referenced from another using @ operator. The $@p$ is syntactically substituted for the protocol of that name.

\paragraph{Interactions.} Figure~\ref{fig:seq-diagram-sc2} depicts the protocols provided above using an UML sequence diagram. The language of the artifacts has already presented in the first scenario.

\begin{figure}
\label{fig:seq-diagram-sc2}
\centering
\includegraphics[width=0.8\textwidth]{resources/interaction-sc2.png}
\caption{Sequence diagram of interactions for Scenario \# 2}
\label{fig:}
\end{figure}

\paragraph{Implementation.} Despite the fact that session delegation takes place, the program still remains very simple. Actually delegating the protocol is straightforward and only consists of passing the socket to service:

\begin{lstlisting}
s_vs.send(user_vu); // pass the remaining protocol
\end{lstlisting}

I have decided to include the whole segment of code to illustrate the following point. 

\begin{lstlisting}
user_vu.outbranch(ACCESS) {
  JSONMessage req_info = user_vu.receive();
  SJServerAddress addr_vs = SJServerAddress.create(p_vs, saas_hname, saas_port);
  SJSocket s_vs = SJRSocket.create(addr_vs); try(s_vs) {
    s_vs.request();
    s_vs.send(user_vu); // pass the remaining protocol    
    s_vs.send(req_info);
  } catch(UnknownHostException uhe) {
    uhe.printStackTrace(); 
  }
}
\end{lstlisting}

To receive a high order message type casting must take place in the case of a protocol, the type of protocol must be explicitly defined:

\begin{lstlisting}
v3na_user_socket = (@p_msg) v3na_sv.receive();
\end{lstlisting}

Where p\_msg is defined in the protocols section. This is a reason why it is good practice to first exclusively write the protocol to be delegated and then include it in the final protocol.

%------------------------------------------------------------------------------


\section{Future Work: InterCloud and Session Types}
\label{sect:highlights}
Cloud computing is moving to the concept where cloud operated by one enterprise interoperating with a clouds of another is powerful idea. So far that is limited to use cases where code running on one cloud explicitly references a service on another cloud. There is no implicit and transparent interoperability. 
Different visions has already proposed in papers \cite{}. The most full picture of cloud inter-networking is depicted by \cite{}. They emphasized the main components of general inter-networking architecture:
\begin{inparaenum}[(\bgroup\bfseries a\egroup)]
\item \textit{Cloud Coordinator}, for bringing out Cloud services;
\item \textit{Cloud Brocker}, ``for mediating between service consumers and Cloud coordinators'';
\item \textit{Cloud Exchange} (e.g. Cloud Integrator), for collecting consumers' demands and locating Cloud providers with them with offers.
\end{inparaenum}

Our approach is to employ multiparty session types \cite{ng2012multiparty} for type-safe conversation between Cloud providers and Cloud Integrators (many-to-many conversation). It starts by specifying the intended interactions as an inter Cloud protocol in the, contract checker, UBF. Then processes for each role (either Cloud provider or Cloud Exchange) are implemented in Erlang or Python (they are best for working with high load applications). Since all the roles should be aware of each other in global network in order to dialog with each other, we are going to use SockJS\footnote{SockJS is an effort to define a protocol between in-browser SockJS-client and its server-side counterparts} protocol for presence and AMQP messaging (it's thin, flexible). Moreover, there is an idea, to extend SockJS protocol during communication initiation to check at runtime that each interaction is correct and as a result the whole communication is safe. As a starting point for dynamic verification observers, we referred to \cite{safe-conver-prog-python} work.

\section{Conclusion}
\label{sect:conclusion}
In today's time, there is an actual need to develop structured, high-level and type-safe techniques for programming and interaction. The presented case studies demonstrated how communication safety can be guaranteed through a combination of static and dynamic type verification. Although session-based programming is on its infancy, it's developed with huge steps and already proved its feasibility in various fields: parallel algorithms \cite{sj-parallel}, event-driven programming \cite{event-driven-sj}, multiparty conversations \cite{sj-business-protocols}. 
%------------------------------------------------------------------------------
% Refs:
%
\label{sect:bib}
\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{easychair}

%------------------------------------------------------------------------------
\appendix



%------------------------------------------------------------------------------
% Index
%\printindex

%------------------------------------------------------------------------------
\end{document}

% EOF
